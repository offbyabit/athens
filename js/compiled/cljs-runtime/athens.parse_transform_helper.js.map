{"version":3,"sources":["athens/parse_transform_helper.cljc"],"mappings":";;AAGA;;;;AAAA,AAAMA,AAGHC;AAHH,AAIE,AAACC,AACC,AAAKC,AAAgBC;AAArB,AACE,AAAI,AAAK,AAASA,AAAM,AAAS,AAACC,AAAKF;AACrC,AAAMG,AAAkB,AAACC,AAAIJ;AACvBK,AAAqB,AAAK,AAACH,AAAKF,AAAiBC;AADvD,AAEE,AAACK,AAAKH,AAAkBE;;AAC1B,AAACC,AAAKN,AAAgBC;;AAN5B,AAQEH","names":["athens.parse-transform-helper/combine-adjacent-strings","coll","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","elements-so-far","elmt","cljs.core/peek","previous-elements","cljs.core/pop","combined-last-string","cljs.core.conj.cljs$core$IFn$_invoke$arity$2"],"sourcesContent":["(ns athens.parse-transform-helper)\n\n\n(defn combine-adjacent-strings\n  \"In a sequence of strings mixed with other values, returns the same sequence with adjacent strings concatenated.\n   (If the sequence contains only strings, use clojure.string/join instead.)\"\n  [coll]\n  (reduce\n    (fn [elements-so-far elmt]\n      (if (and (string? elmt) (string? (peek elements-so-far)))\n        (let [previous-elements (pop elements-so-far)\n              combined-last-string (str (peek elements-so-far) elmt)]\n          (conj previous-elements combined-last-string))\n        (conj elements-so-far elmt)))\n    []\n    coll))\n"]}